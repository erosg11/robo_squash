function [ position, speed, axis, t ] = run_until_colision( position, speed, aceleration, g, limits, d, n, m )
%run_until_colision
%Determina quando ocorrerá uma colisão com o chão, ou contra alguma parede
% Parâmetros:
% Position: Vetor com posições nos eixos x, y e z
% Speed: Velocidade nos mesmos eixos
% g: Aceleração da gravidade
% Limits: matriz com os limites nos eixos x e y, maior, menor
% d: Diâmetro da bola
% n: Viscosidade do ar
% m: Massa da bola

% Sabendo que a força de arrasto pode ser calculada como:
% m * (-s'') = 3 * pi * n * d * s'
% Calculamos o resultado da EDO
% E no caso do eixo z, nós temos além disso:
% m * (g - s'') = 3 * pi * n * d * s'

% Não temos uma forma intuitiva de calcular a fução inversa (t(s))
% Então somos obrigados a resolver de forma numérica usando a função solve

syms t
assume(t >= 0)

if sign(speed(1)) == 1
    limit_x = limits(1,1);
else
    limit_x = limits(1,2);
end

x = (3*pi*d*n*(m*speed(1) + 3*pi*d*n*position(1)) - ...
    (aceleration(1))*m^2 + 3*pi*d*(aceleration(1))*m*n*t)/ ...
    (9*pi^2*d^2*n^2) + (exp(-(3*pi*d*n*t)/m)* ...
    ((aceleration(2))*m^2 - 3*pi*d*n*speed(2)*m))/(9*pi^2*d^2*n^2);

t_x = solve(x == limit_x, t);

if sign(speed(2)) == 1
    limit_y = limits(2,1);
else
    limit_y = limits(2,2);
end

y = (m*speed(2) + 3*pi*d*n*position(2))/(3*pi*d*n) - ...
    (m*speed(2)*exp(-(3*pi*d*n*t)/m))/(3*pi*d*n);

t_y = solve(y == limit_y, t);

z = (3*pi*d*n*(m*speed(3) + 3*pi*d*n*position(3)) - ...
    (aceleration(3) - g)*m^2 + 3*pi*d*(aceleration(3) - g)*m*n*t)/ ...
    (9*pi^2*d^2*n^2) + (exp(-(3*pi*d*n*t)/m)* ...
    ((aceleration(3) -g)*m^2 - 3*pi*d*n*speed(3)*m))/(9*pi^2*d^2*n^2);

% z = (327*m^2 + 100*pi*d*n*(m*speed(3) + 3*pi*d*n*position(3)) - ... 
%     981*pi*d*m*n*t)/(300*pi^2*d^2*n^2) - (exp(-(3*pi*d*n*t)/m)*(327*m^2 ...
%     + 100*pi*d*n*speed(3)*m))/(300*pi^2*d^2*n^2);

t_z = solve(z == 0, t);

[t, axis] = min(double([t_x; t_y; t_z]));

[position, speed] = run_until(position, speed, aceleration, t, d, n, m);

end

